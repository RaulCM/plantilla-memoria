%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Plantilla de memoria en LaTeX para la ETSIT - Universidad Rey Juan Carlos
%%
%% Por Gregorio Robles <grex arroba gsyc.urjc.es>
%%     Grupo de Sistemas y Comunicaciones
%%     Escuela Técnica Superior de Ingenieros de Telecomunicación
%%     Universidad Rey Juan Carlos
%% (muchas ideas tomadas de Internet, colegas del GSyC, antiguos alumnos...
%%  etc. Muchas gracias a todos)
%%
%% La última versión de esta plantilla está siempre disponible en:
%%     https://github.com/gregoriorobles/plantilla-memoria
%%
%% Para obtener PDF, ejecuta en la shell:
%%   make
%% (las imágenes deben ir en PNG o JPG)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[a4paper, 12pt]{book}
%\usepackage[T1]{fontenc}

\usepackage[a4paper, left=2.5cm, right=2.5cm, top=3cm, bottom=3cm]{geometry}
\usepackage{times}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel} % Comenta esta línea si tu memoria es en inglés
\usepackage{url}
%\usepackage[dvipdfm]{graphicx}
\usepackage{graphicx}
\usepackage{float}  %% H para posicionar figuras
\usepackage[nottoc, notlot, notlof, notindex]{tocbibind} %% Opciones de índice
\usepackage{latexsym}  %% Logo LaTeX
\usepackage{hyperref}
\usepackage{dirtree}
\usepackage{makecell}
\usepackage{pgfplots} 
\usetikzlibrary{patterns}

\title{Memoria del Proyecto}
\author{Raúl Cano Montero}

\renewcommand{\baselinestretch}{1.5}  %% Interlineado

\begin{document}

\renewcommand{\refname}{Bibliografía}  %% Renombrando
\renewcommand{\appendixname}{Apéndice}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% PORTADA

\begin{titlepage}
\begin{center}
\includegraphics[scale=0.8]{img/URJ_logo_Color_POS.png}

\vspace{1.75cm}

\Large
GRADO EN INGENIERÍA EN TECNOLOGÍAS DE LA TELECOMUNICACIÓN

\vspace{0.4cm}

\large
Curso Académico 2020/2021

\vspace{0.8cm}

Trabajo Fin de Grado

\vspace{2.5cm}

\LARGE
CREACIÓN AUTOMÁTICA DE PULL-REQUESTS A PARTIR DE RESULTADOS DE PYLINT

\vspace{4cm}

\large
Autor : Raúl Cano Montero \\
Tutor : Dr. Gregorio Robles
\end{center}
\end{titlepage}

\newpage
\mbox{}
\thispagestyle{empty} % para que no se numere esta pagina


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Para firmar
\clearpage
\pagenumbering{gobble}
\chapter*{}

\vspace{-4cm}
\begin{center}
\LARGE
\textbf{Trabajo Fin de Grado}

\vspace{1cm}
\large
Creación Automática de Pull-Requests a partir de Resultados de Pylint

\vspace{1cm}
\large
\textbf{Autor :} Raúl Cano Montero \\
\textbf{Tutor :} Dr. Gregorio Robles

\end{center}

\vspace{1cm}
La defensa del presente Proyecto Fin de Carrera se realizó el día \qquad$\;\,$ de julio de 2021, siendo calificada por el siguiente tribunal:


\vspace{0.5cm}
\textbf{Presidente:}

\vspace{1.2cm}
\textbf{Secretario:}

\vspace{1.2cm}
\textbf{Vocal:}


\vspace{1.2cm}
y habiendo obtenido la siguiente calificación:

\vspace{1cm}
\textbf{Calificación:}


\vspace{1cm}
\begin{flushright}
Fuenlabrada, a \qquad$\;\,$ de julio de 2021
\end{flushright}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Dedicatoria

\chapter*{}
\pagenumbering{Roman} % para comenzar la numeracion de paginas en numeros romanos
\begin{flushright}
%TODO
\textit{Dedicado a \\
mi familia / mi abuelo / mi abuela}
\end{flushright}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Agradecimientos

\chapter*{Agradecimientos}
%\addcontentsline{toc}{chapter}{Agradecimientos} % si queremos que aparezca en el índice
\markboth{AGRADECIMIENTOS}{AGRADECIMIENTOS} % encabezado 
%TODO
Aquí vienen los agradecimientos\ldots Aunque está bien acordarse de la pareja, no hay que olvidarse de dar las gracias a tu madre, que aunque a veces no lo parezca disfrutará tanto de tus logros como tú\ldots 
Además, la pareja quizás no sea para siempre, pero tu madre sí.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Resumen

\chapter*{Resumen}
%\addcontentsline{toc}{chapter}{Resumen} % si queremos que aparezca en el índice
\markboth{RESUMEN}{RESUMEN} % encabezado

El objetivo de este Trabajo de Fin de Grado es analizar proyectos realizados en lenguaje Python para evaluar el nivel de cumplimiento con la guía de estilo PEP8 y corregirlos para aumentar éste.

El proyecto se basa en el modelo de arquitectura cliente-servidor y se ha desarrollado como una aplicación web accesible desde Internet que permite a cualquier usuario evaluar el nivel de cumplimiento de sus proyectos con PEP8 mediante el análisis de repositorios alojados en GitHub.
Algunos de los errores observados son corregibles por la aplicación y los cambios se suben al repositorio de GitHub mediante el uso de Pull-Requests.

La aplicación ha sido desarrollada en lenguaje Python y se han usado tecnologías como Django, HTML, CSS, JavaScript o PostgreSQL.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Resumen en inglés

\chapter*{Summary}
%\addcontentsline{toc}{chapter}{Summary} % si queremos que aparezca en el índice
\markboth{SUMMARY}{SUMMARY} % encabezado
This Final Degree Project aims to analyze projects developed in Python in order to evaluate their compliace level with the style guide for Python known as PEP8 and correct their code to increase their compliance level.

This project is based on the client-server model and has been developed as a web application accesible from the Internet that allows any user to evaluate the compliance level of their projects with PEP8 by analyzing repositories hosted on GitHub.
Some of the detected errors are correctables by the application and the changes are committed and uploaded to the GitHub repository using Pull-Requests.

The application has been developed in Python language and technologies such as Django, HTML, CSS, JavaScript or PostgreSQL have been used.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ÍNDICES %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Las buenas noticias es que los índices se generan automáticamente.
% Lo único que tienes que hacer es elegir cuáles quieren que se generen,
% y comentar/descomentar esa instrucción de LaTeX.

%%%% Índice de contenidos
\tableofcontents 
%%%% Índice de figuras
\cleardoublepage
\addcontentsline{toc}{chapter}{Lista de figuras} % para que aparezca en el indice de contenidos
\listoffigures % indice de figuras
%%%% Índice de tablas
\cleardoublepage
\addcontentsline{toc}{chapter}{Lista de tablas} % para que aparezca en el indice de contenidos
\listoftables % indice de tablas


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% INTRODUCCIÓN %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\chapter{Introducción}
\label{chap:intro}
\label{sec:intro} % etiqueta para poder referenciar luego en el texto con ~\ref{sec:intro}
\pagenumbering{arabic} % para empezar la numeración de página con números
Este documento contiene la memoria de mi trabajo de fin de grado de ingeniería en tecnologías de la telecomunicación.
El proyecto consiste en la creación automática de Pull-Requests que aumenten el nivel de cumplimiento con la guía de estilo PEP8 de repositorios escritos Python que se encuentren alojados en GitHub.
Para ello se desarrollará una aplicación que analice dicho código y posteriormente pueda corregirlo para aumentar dicho nivel de cumplimiento.

La aplicación será de tipo web, desarrollada con Django y haciendo uso de tecnologías como Python, HTML, CSS o JavaScript, y será accesible desde Internet para que cualquier usuario pueda acceder a la aplicación y realizar el análisis y la corrección sobre los repositorios que quiera, por lo que se realizará un despliegue de la aplicación en Heroku.

El análisis se ejecutará mediante la herramienta Pylint realizando un escaneo de todos los ficheros con extensión \textit{.py} y obteniendo la lista de errores indicados por Pylint.
Algunos de estos errores serán corregibles por la aplicación, de manera que se pueda aumentar el nivel de cumplimiento indicado anteriormente.

El código analizado por la aplicación estará almacenado en plataformas de almacenamiento de repositorios, como GitHub o GitLab, y las modificaciones realizadas serán subidas automáticamente al repositorio correspondiente mediante el uso de Pull-Requests.

Además, la aplicación mostrará información sobre el número total de errores encontrados y corregidos en los repositorios que han sido analizados.


\section{Estructura de la memoria}
\label{sec:estructura}

La memoria está estructurada de la siguiente manera:

\begin{itemize}
  \item En el capítulo~\ref{chap:intro} se hace una introducción al proyecto.
  \item En el capítulo~\ref{chap:objetivos} se muestran los objetivos generales y específicos del proyecto y la planificación temporal del mismo.
  \item En el capítulo~\ref{chap:estado} se presenta el estado del arte, introduciendo las diferentes tecnologías usadas en el proyecto.
  \item En el capítulo~\ref{chap:diseno} se describe de manera detallada el diseño del proyecto, profundizando en la arquitectura general y el diseño e implementación del servidor.
  \item En el capítulo~\ref{chap:experimentos} se detallan las diferentes pruebas realizadas para probar el funcionamiento correcto de la aplicación durante diferentes etapas del desarrollo.
  \item En el capítulo~\ref{chap:resultados} se explican los resultados obtenidos tras ejecutar la aplicación con proyectos reales. 
  \item En el capítulo~\ref{chap:conclusiones} se presentan las conclusiones finales acerca del proyecto.
\end{itemize}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% OBJETIVOS %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage % empezamos en página impar
\chapter{Objetivos} % título del capítulo (se muestra)
\label{chap:objetivos} % identificador del capítulo (no se muestra, es para poder referenciarlo)

\section{Objetivo general} % título de sección (se muestra)
\label{sec:objetivo-general} % identificador de sección (no se muestra, es para poder referenciarla)

El objetivo de este Trabajo de Fin de Grado es realizar el análisis, mediante la herramienta Pylint, la corrección del código y la creación de Pull-Requests sobre proyectos desarrollados en Python y almacenados en GitHub, para que éstos cumplan con las normas recogidas en la guía de estilo de Python denominada PEP8

\section{Objetivos específicos}
\label{sec:objetivos-especificos}

Para poder cumplir con el objetivo general se han tenido en cuenta los siguientes objetivos específicos:

\begin{itemize}
	\item \textbf{Trabajar con proyectos reales.} Utilizar la aplicación para analizar y corregir proyectos reales.
	\item \textbf{Aplicación web.} Desarrollar como una aplicación web para hacer mejor y más sencilla la experiencia de usuario.
	\item \textbf{Accesibilidad desde Internet.} Hacer que la aplicación esté en funcionamiento continuamente y sea accesible desde cualquier ubicación.
	\item \textbf{Compatibilidad con el servidor GitLab de la ETSIT.} Hacer que la aplicación sea compatible con el GitLab de la ETSIT para permitir que los alumnos de la escuela puedan analizar y corregir sus proyectos.
	\item \textbf{Análisis de aceptación de las Pull-Requests.} Evaluar la aceptación de los cambios realizados en los proyectos mediante el análisis del estado de las Pull-Requests realizadas.
\end{itemize}


\section{Planificación temporal}
\label{sec:planificacion-temporal}
%TODO
A mí me gusta que aquí pongáis una descripción de lo que os ha llevado realizar el trabajo.
Hay gente que añade un diagrama de GANTT.
Lo importante es que quede claro cuánto tiempo llevas (tiempo natural, p.ej., 6 meses) y a qué nivel de esfuerzo (p.ej., principalmente los fines de semana).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ESTADO DEL ARTE %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\chapter{Estado del arte}
\label{chap:estado}

En este capítulo se describen brevemente las principales tecnologías utilizadas en el desarrollo del proyecto.

\section{Python} 
\label{sec:python}
Python \cite{python} es un lenguaje de programación Open Source escrito por Guido van Rossum entre finales de los años 80 y principios de los 90. El objetivo de la creación de Python era tener un lenguaje de programación con una sintaxis sencilla, como el lenguaje ABC en el que se inspira, añadiendo la posibilidad de realizar llamadas al sistema con compatibilidad con distintos sistemas operativos.

Python es un lenguaje de programación interpretado, interactivo y orientado a objetos. Al ser un lenguaje interpretado se reduce el tiempo entre la escritura del código y la ejecución del mismo, ya que no hay que compilarlo cada vez que se realice una modificación del código. Sin embargo, ésto implica que sea necesaria la instalación de un intérprete en la máquina que va a ejecutar el código y aumenta el tiempo de la ejecución respecto a los lenguajes compilados.

Python incorpora módulos, excepciones, tipado dinámico, tipos de datos dinámicos de muy alto nivel y clases. La librería estándar de Python le permite cubrir distintas áreas, como el procesamiento de cadenas de texto, protocolos de red, ingeniería del software e interacción con el sistema operativo.

Además de la programación orientada a objetos, soporta múltiples paradigmas de programación como la programación procedimental y la programación funcional y también es compatible con diversos sistemas operativos, incluyendo Windows y múltiples variantes de Unix, como Linux y macOS.

Actualmente Python es uno de los lenguajes de programación más utilizados~\cite{stackoverflowsurvey}.

\section{PEP 8} 
\label{sec:pep8}
Python Enhancement Proposal 8, más conocida como PEP 8~\cite{pep8}, es una guía de estilo para código escrito en Python que contiene recomendaciones y convenciones dirigidas a mejorar la consistencia y legibilidad del código.
Algunas de las convenciones indicadas por PEP 8 son las siguientes:
\begin{itemize}
	\item \textbf{Tabulación}: Se debe tabular utilizando 4 espacios por cada nivel de tabulación.
	\item \textbf{Caracteres por línea}: Cada línea de código debe tener, como máximo, una longitud de 79 caracteres.
	\item \textbf{Imports}: Los módulos adicionales deben ser importados al inicio de cada fichero y sólo debe haber uno por línea.
	\item \textbf{Espacios antes y después de operadores}: Antes y después de cada operador debe haber un único espacio.
	\item \textbf{Nomenclatura}: Cada elemento tiene definidas unas normas distintas al realizar su declaración.
\end{itemize}

PEP 8 también nos indica que las distintas normas pueden ser ignoradas en determinados casos como, por ejemplo:
\begin{itemize}
	\item Cuando se añade código a una librería ya existente que sigue un estilo distinto se debe respetar dicho estilo para mantener la consistencia dentro de dicha librería.
	\item En caso de que el código necesite funcionar en versiones antiguas de Python y modificarlo suponga una incompatibilidad.
	\item Cuando modificar el código dificulte la lectura y comprensión del mismo. 
\end{itemize}

\section{Pylint} 
\label{sec:pylint}
Pylint~\cite{pylint} es una herramienta de análisis de código escrito en Python que comprueba si hay incumplimiento de la guía de estilo PEP 8. Es un analizador de código estático, lo que facilita el análisis del código ya que se realiza sin tener que ejecutarlo.

Pylint identifica los errores mediante mensajes a los que se les asigna una letra seguida de un código numérico, cada letra especifica un tipo de mensaje:
\begin{itemize}
	\item \textbf{I}: Mensajes informativos. No penalizan en la calificación emitida el final de análisis.
	\item \textbf{R}: Refactorizaciones para solucionar errores en la métrica.
	\item \textbf{C}: Convenciones para violaciones estándar del código.
	\item \textbf{W}: Warnings o advertencias causadas por problemas de estilo o problemas menores de programación.
	\item \textbf{E}: Errores debidos a problemas importantes de programación.
	\item \textbf{F}: Errores fatales que impiden continuar con el proceso.
\end{itemize}

La salida de Pylint puede ser configurada mediante argumentos en el momento de ejecución o mediante un fichero de configuración llamado \textit{pylintrc}.
Dicha salida se divide en 3 secciones: análisis del código fuente, informes y calificación.

\subsubsection{Análisis del código fuente}

Primera y principal sección de la salida de Pylint. Muestra los errores que Pylint ha encontrado al analizar todas las líneas del código.
Por defecto, para cada error detectado indica el tipo correspondiente, en qué línea y columna se ha encontrado y el mensaje correspondiente a dicho error.
Esta salida es configurable mediante un template, permitiendo mostrar los siguientes elementos a la información de cada error detectado:
\begin{itemize}
	\item \textit{path}: Ruta relativa del fichero analizado.
	\item \textit{abspath}: Ruta absoluta del fichero analizado.
	\item \textit{line}: Número de línea.
	\item \textit{column}: Número de columna.
	\item \textit{module}: Nombre del módulo.
	\item \textit{obj}: Nombre del objeto dentro del módulo (si corresponde).
	\item \textit{msg}: Texto del mensaje.
	\item \textit{msg\_id}: Código del mensaje.
	\item \textit{symbol}: Nombre del mensaje.
	\item \textit{C}: Letra identificativa de la categoría del mensaje.
	\item \textit{category}: Nombre completo de la categoría del mensaje.
\end{itemize} 

\subsubsection{Informes}

Segunda sección de la salida de Pylint. 
Por defecto, muestra un conjunto de informes acerca de distintos aspectos del código analizado, pero puede ser desactivado mediante un argumento en el momento de ejecutar el análisis.
Los informes mostrados son los siguientes:
\begin{itemize}
	\item Numero de módulos analizados.
	\item Para cada módulo, porcentaje de errores y warnings.
	\item Número total de errores y warnings.
	\item Porcentaje de clases, funciones y módulos que incluyen docstrings y comparación con la ejecución previa del análisis.
	\item Porcentaje de clases, funciones y módulos con un nombre correcto según el estándar y una comparación con la ejecución previa del análisis.
	\item Lista de dependencias externas encontradas en el código y dónde aparecen.
\end{itemize}

\subsubsection{Calificación}

Tercera y última sección de la salida de Pylint.
Muestra una calificación global, siendo 10.0 el máximo, para el código analizado y lo compara con la calificación obtenida en la ejecución previa del análisis.
Al igual que los informes, puede ser desactivado mediante un argumento en el momento de ejecutar el análisis.

\section{Django} 
\label{sec:django}
Django\cite{django} es un framework de desarrollo de aplicaciones web de código abierto escrito en Python. Django está basado en una variación de la arquitectura MVC (Model-View-Controller) a la que denominan MVT (Model-View-Template):
\begin{itemize}
	\item \textbf{Model}: Datos con los que el sistema trabaja. Se definen en el fichero models.py.
	\item \textbf{View}: Describe qué datos se presentan mediante los ficheros views.py y urls.py. 
	\item \textbf{Template}: Definido por las plantillas HTML y CSS que describen cómo se presentan los datos.
\end{itemize}

\section{PostgreSQL} 
\label{sec:postgresql}

PostgreSQL~\cite{postgresql} es un sistema de gestión de bases de datos relacionales de código abierto basado en POSTGRES. PostgreSQL es compatible con gran parte del estándar SQL, añade algunas características propias, como el control de concurrencias multiversión o la compatibilidad con consultas complejas, y permite al usuario añadir nuevos tipos de datos, funciones u operadores.

\section{HTML} 
\label{sec:html}

HTML (Hypertext Markup Language)~\cite{htmlcss} es el lenguaje de marcado estándar para la creación de páginas web. Este estándar está a cargo del World Wide Web Consortium (W3C) y es compatible con todos los navegadores web.
Con HTML se define la estructura de las páginas web mediante la utilización de distintas etiquetas.

\section{CSS} 
\label{sec:css}

CSS (Cascading Style Sheets)~\cite{htmlcss} es un lenguaje de diseño web utilizado para definir la apariencia y el estilo visual de una página web. Al igual que HTML, es un estándar a cargo del World Wide Web Consortium (W3C).
CSS establece cómo se muestran los elementos declarados en un documento HTML definiendo propiedades como los colores, fuentes y diseño. Para ello CSS hace uso de reglas, formadas por selectores, que indican sobre qué elementos HTML se aplican, y declaraciones, que definen y modifican las propiedades.
CSS es independiente de HTML y se puede llevar a cabo desde un fichero separado, lo que facilita el mantenimiento y la reutilización de las hojas de estilo.


\section{Bootstrap} 
\label{sec:bootstrap}

Bootstrap~\cite{bootstrap} es un framework de código abierto dirigido al desarrollo front-end de páginas web. Es una biblioteca que contiene herramientas HTML, CSS y JavaScript que facilitan el diseño y ayudan a realizar modificaciones de manera más sencilla en el estilo visual. Bootstrap contiene plantillas predefinidas con diferentes estilos de botones, formularios, desplegables o pestañas, entre otros componentes. Una de las características más importantes de Bootstrap es que también aporta el diseño responsive, que adapta automáticamente la presentación de la página web a diferentes tipos de dispositivos teniendo en cuenta el tamaño de pantalla y la resolución, lo que facilita la visualización y aumenta la compatibilidad de las páginas web.

\section{JavaScript} 
\label{sec:javascript}

JavaScript~\cite{javascript} es un lenguaje de programación interpretado, orientado a objetos, imperativo, multiparadigma, de tipado débil y dinámico y basado en prototipos. Tiene una sintaxis inspirada en la de Java y C++, con sentencias que funcionan igual que en esos lenguajes.
Su uso principal es el scripting en páginas web dirigido a establecer el comportamiento de éstas al suceder un evento determinado. La ejecución de estos scripts se realiza en el lado del cliente, en el navegador web, sin tener acceso al lado del servidor.
El uso de JavaScript está ampliamente extendido debido a que es compatible con cualquier navegador y sistema operativo.

\section{jQuery} 
\label{sec:jquery}

jQuery~\cite{jquery} es una librería de JavaScript de código abierto que simplifica la interacción entre JavaScript y HTML. jQuery facilita la manipulación del HTML, el manejo de eventos, el desarrollo de animaciones y el uso de AJAX y es compatible con cualquier navegador web y sistema operativo actual.

\section{Chart.js} 
\label{sec:chartjs}

Chart.js~\cite{chartjs} es una librería de JavaScript de código abierto dirigida a la representación y visualización de datos. Permite generar gráficos de distintos tipos, como barras, líneas, circulares o de dispersión, entre otros, y personalizar cómo se muestran dichos gráficos.
Actualmente es una de las librerías de visualización de datos en JavaScript más populares en GitHub.

\section{JSON} 
\label{sec:json}

JSON~\cite{json} (JavaScript Object Notation) es un formato de intercambio de datos fácil de leer y escribir para humanos y fácil de generar e interpretar para las máquinas. Como su nombre indica, está basado en la sintaxis de objetos de JavaScript, teniendo una estructura formada por pares de nombre/valor.
JSON es independiente de cualquier lenguaje y, por ello, es compatible con la gran mayoría de los lenguajes de programación actuales.

\section{API-REST} 
\label{sec:api}

Una API (Application Programming Interface) es un conjunto de instrucciones y protocolos ofrecidos por determinadas aplicaciones para dar acceso a su propia información o funciones. La API actúa como intermediario entre la propia aplicación y el solicitante y devuelve a éste último una respuesta con el resultado de la operación realizada o con la información solicitada.

Una API REST es un tipo de API en el que el acceso está basado en arquitectura REST (Representational State Transfer), por lo que las llamadas a dicha API se llevan a cabo mediante peticiones HTTP y el uso de objetos XML o JSON.

\section{Git} 
\label{sec:git}

Git\cite{git} es un software de código abierto de control de versiones diseñado por Linus Torvald para facilitar la gestión y el trabajo en equipo en proyectos de desarrollo de software.
Para un proyecto almacenado en un repositorio, Git permite que cada integrante del equipo tenga una versión en local del proyecto y vaya subiendo sus modificaciones al repositorio.

El funcionamiento de Git se basa en la creación, uso y mezcla de ramas dentro del proyecto, existiendo una rama principal, conocida como master, y creándose ramas secundarias para realizar las modificaciones en el código. Una vez se realicen las modificaciones, la rama secundaria se mezcla con la rama master y cuando otros miembros del equipo actualicen su rama master descargarán los cambios realizados sin que esto afecte a su trabajo.

\section{GitHub} 
\label{sec:github}

GitHub~\cite{github} es un servicio web, propiedad de Microsoft, que almacena repositorios de proyectos de desarrollo software que utilizan el sistema de control de versiones Git, siendo actualmente la plataforma de almacenamiento de repositorios más usada. Permite la creación de repositorios públicos, que podrán ser vistos y descargados por cualquier usuario, y repositorios privados, que únicamente serán visibles por los colaboradores de dicho repositorio.
\subsubsection{Pull-Request}
Cualquier usuario puede colaborar en proyectos públicos mediante la creación peticiones conocidas como Pull-Requests, que permiten que un usuario informe al dueño de un repositorio de los cambios que ha realizado para dicho repositorio.
Para esto, un usuario externo a un repositorio crea un fork del mismo, crea una nueva rama dentro de ese fork para llevar a cabo las modificaciones y, una vez realizado los commits y push, puede crear la Pull-Request.
Durante la creación de una Pull-Request se le da un nombre y una descripción a la misma y se tiene la posibilidad de visualizar y revisar los commits incluidos junto a las diferencias entre el código del repositorio original y el de la Pull-Request.
Una vez creada una Pull-Request el usuario que la ha creado puede seguir realizando commits sobre la misma y además otros usuarios pueden participar en las modificaciones llevadas a cabo y sugerir cambios, añadir comentarios o realizar nuevos commits sobre la Pull-Request.
Cuando el propietario del repositorio original esté de acuerdo con los cambios propuestos en la Pull-Request, puede aceptarla, haciendo \textit{merge} y fusionando así el contenido de la Pull-Request con el del repositorio original.

\section{GitLab} 
\label{sec:gitlab}

GitLab~\cite{gitlab} es un servicio web de código abierto que almacena repositorios de proyectos de desarrollo software que utilizan el sistema de control de versiones Git. Al igual que GitHub, permite la creación de repositorios públicos y privados y tiene un sistema de Pull-Requests que, en este caso, se denominan Merge-Requests.
GitLab permite la instalación en un servidor privado para no hacer uso de la plataforma pública que se encuentra abierta a todo el mundo.

\section{Heroku} 
\label{sec:Heroku}

Heroku~\cite{heroku} es una plataforma como servicio (PaaS) que permite alojar aplicaciones en la nube. Es compatible con aplicaciones desarrolladas en Node.js, Ruby, Python, Java, PHP, Go, Scala y Clojure y con bases de datos PostgreSQL, MongoDB y Redis.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% DISEÑO E IMPLEMENTACIÓN %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\chapter{Diseño e implementación}
\label{chap:diseno}

En este capítulo se describe de manera detallada el diseño y la implementación del proyecto.

\section{Arquitectura general} 
\label{sec:arquitectura}

La arquitectura de la aplicación se basa en el modelo cliente-servidor representado en la figura~\ref{fig:cliente-servidor}.
En este modelo existen dos partes diferenciadas: cliente y servidor.

Cliente y servidor puede encontrarse en la misma máquina, pero en el caso de este proyecto siempre van a estar en máquinas separadas, ya que la aplicación se encuentra desplegada en Heroku y la comunicación entre ambas partes se lleva a cabo a través de internet mediante protocolo HTTP.

\begin{figure}
  \centering
  \includegraphics[width=9cm, keepaspectratio]{img/cliente-servidor.png}
  \caption{Modelo cliente-servidor.}\label{fig:cliente-servidor}
\end{figure}

\subsection{Cliente}
\label{subsec:arq_cliente}

La parte cliente está formada por el navegador web desde el que el usuario accede a la aplicación. 
El navegador recibe la página web en forma de código HTML y lo interpreta para mostrarlo al usuario para su interacción.
Las acciones que el usuario lleve a cabo sobre la página web son convertidas en peticiones HTTP por el navegador web y se envían al servidor, que las procesa y devuelve una respuesta al cliente en forma de código HTML.
Desde la parte cliente no se realiza ninguna ejecución a excepción de los scripts JavaScript que puedan encontrarse dentro del HTML.

\subsection{Servidor}
\label{subsec:arq_servidor}

La parte servidor está desplegada en Heroku y contiene la aplicación desarrollada en Django y una base de datos PostgreSQL tal y como se ve reflejado en la figura~\ref{fig:servidor}.

El servidor desplegado en Heroku recibe las peticiones HTTP realizadas sobre una determinada URL y Django las procesa realizando las acciones correspondientes para la petición recibida y, si es necesario, realiza una consulta a la base de datos PostgreSQL pudiendo ser ésta para obtener o modificar datos almacenados en dicha base de datos.
Por último, el servidor devuelve al cliente el código HTTP con la respuesta a la petición realizada.
\newline
\begin{figure}[h]
  \centering
  \includegraphics[width=9cm, keepaspectratio]{img/servidor.png}
  \caption{Arquitectura del servidor.}\label{fig:servidor}
\end{figure}

\section{Diseño e implementación del servidor} 
\label{sec:diseno_servidor}

El funcionamiento global de la aplicación y sus etapas son las representadas en la figura~\ref{fig:uso}.

El inicio del uso de la aplicación es la introducción en un formulario de la URL del repositorio que se va analizar. Una vez comprobado que la URL introducida apunta a un repositorio, se descargan los datos del mismo y se lleva a cabo la primera de las etapas principales, el análisis del código mediante la utilización de Pylint.
Una vez se ha analizado el código y se ha confirmado que se quieren llevar a cabo las modificaciones correspondientes a los errores detectados por Pylint, se realiza un fork del repositorio, se descarga el código de dicho fork y se realiza la segunda etapa principal, la corrección de los errores.
Cuando se ha terminado con la corrección se llega al final del proceso con la realización de una Pull-Request/Merge-Request con las modificaciones realizada en el código.

\begin{figure}[h]
  \centering
  \includegraphics[width=12cm, keepaspectratio]{img/uso.png}
  \caption{Etapas del uso de la aplicación.}\label{fig:uso}
\end{figure}

\subsection{Django}
\label{subsec:diseño_django}

Como ya se ha explicado en la sección~\ref{sec:django}, Django se basa en una arquitectura MVT como la representada en la figura~\ref{fig:django}.

Las peticiones HTTP son procesadas por la parte \textit{Views} que realiza las acciones correspondientes y, si es necesario, se comunica \textit{Model} para obtener o modificar la información almacenada en la base de datos.
Una vez realizado el procesamiento, es la parte \textit{Templates} la que se encarga de construir la respuesta HTTP a partir de los datos proporcionados por \textit{Views} y las plantillas HTML.

Esta respuesta HTTP es enviada de vuelta al cliente, que visualiza la página construida por \textit{Templates}, mostrando los datos de \textit{Model} que han sido procesados por \textit{Views}.

\begin{figure}[h]
  \centering
  \includegraphics[width=12cm, keepaspectratio]{img/django.png}
  \caption{Arquitectura Django.}\label{fig:django}
\end{figure}

\subsubsection{Directorios y ficheros}
\label{subsubsec:django_directorios}

En la figura~\ref{fig:directorios} se pueden observar los directorios y ficheros que componen la parte Django de la aplicación. Los ficheros y directorios más importantes y sus funciones son los siguientes:

\begin{itemize}
	\item \textbf{models.py}: Define el modelo de datos a utilizar en la base de datos de la aplicación. Dentro de la arquitectura MVT de Django, pertenece a \textit{Model}.
	\item \textbf{views.py}: En él se definen las vistas encargadas de leer y procesar el contenido de las peticiones HTTP realizadas a la aplicación para después realizar las acciones correspondientes.
	Como su propio nombre indica, se encuentra dentro de la parte \textit{Views} definida en el modelo de arquitectura MVT.
	\item \textbf{urls.py}: A través de este fichero se gestiona el acceso a los recursos (URLs) de la aplicación.
	En él se indican, mediante el uso de expresiones regulares, los recursos que son accesibles en la aplicación y se asigna a cada uno una función definida en el fichero views.py. Junto a views.py, pertenece a la parte \textit{Views} definida en el modelo de arquitectura MVT.
	\item \textbf{pylint\_errors.py}: Fichero que contiene las funciones encargadas de corregir los errores analizados por Pylint.
	\item \textbf{tests.py}: Fichero que contiene los tests unitarios desarrollados para comprobar que las funciones de la aplicación se comportan correctamente.
	\item \textbf{template}: Directorio que contiene las plantillas HTML que van a formar el cuerpo de la respuesta HTTP que se da al cliente. En su interior se encuentran los directorios \textit{es}, que contiene las plantillas en castellano, \textit{en}, que contienen las plantillas en inglés e \textit{images}, que contiene las imágenes utilizadas por las plantillas HTML. También se encuentra el fichero \textit{themes.css}, que actúa como hoja de estilo para toda la aplicación. Los ficheros y directorios de su interior confirman la parte \textit{Templates} del modelo de arquitectura MVT.
\end{itemize}

\begin{figure}
  \centering
  \includegraphics[height=8cm, keepaspectratio]{img/directorios.png}
  \caption{Directorios y ficheros de Django.}\label{fig:directorios}
\end{figure}

\subsubsection{Recursos}
\label{subsubsec:django_recursos}
Los recursos accesibles definidos en \textit{urls.py} son los siguientes:
\begin{itemize}
	\item \textbf{/}: Recurso que devuelve la página principal de la aplicación.
	Llama a la vista \textit{views.main}.
	\item \textbf{/repo/id}: Muestra la información correspondiente al repositorio del id indicado y permite llevar a cabo el análisis del mismo y la corrección de los errores detectados.
	Llama a la vista \textit{views.repo}.
	\item \textbf{/list}: Muestra la información de todas las Pull-Requests/Merge-Requests que se han llevado a cabo.
	Llama a la vista \textit{views.list}.
	\item \textbf{/error-list}: Muestra dos gráficas, una con el recuento del número de veces que se ha corregido cada error y otra con el estado actual de las Pull-Requests/Merge-Requests realizadas.
	Llama a la vista \textit{views.error\_list}.
	\item \textbf{/guide}: Contiene una guía de uso de la aplicación. 
	Llama a la vista \textit{views.guide}.
	\item \textbf{/contact}: Muestra los datos de contacto.
	Llama a la vista \textit{views.contact}.
	\item \textbf{/es}: Cambia el idioma del usuario a castellano.
	Llama a la vista \textit{views.es}.
	\item \textbf{/en}: Cambia el idioma del usuario a inglés.
	Llama a la vista \textit{views.en}.
\end{itemize}

\subsubsection{Vistas}
\label{subsubsec:django_vistas}
 Las vistas de Django definidas en el fichero \textit{views.py} y sus funciones son las siguientes:
\begin{itemize}
	\item \textbf{main}: Si recibe un GET, devuelve el template \textit{main.html}.
	Mientras que si recibe un POST evalúa el contenido introducido en el formulario y, dependiendo de éste, pueden producirse varias situaciones:
	\begin{itemize}
		\item El contenido está vacío: se devuelve el template \textit{error.html}.
		\item El contenido no corresponde a un repositorio: se devuelve el template \textit{error\_repo.html}.
		\item Se ha introducido un repositorio que tiene una Pull-Request/Merge-Request realizada por la aplicación en estado abierto: se devuelve el template \textit{request\_exists.html}.
		\item Se ha introducido un repositorio sin ninguna Pull-Request/Merge-Request realizada por la aplicación en estado abierto: se redirige al recurso \textit{/repo/id}.
	\end{itemize}
	\item \textbf{repo}: Si recibe un GET, devuelve el template \textit{repo\_data.html}.
	Mientras que si recibe un POST evalúa el nombre del formulario que ha realizado la petición y, dependiendo de éste, pueden producirse varias situaciones:
	\begin{itemize}
		\item \textit{pylint}: Se lanza la función asíncrona que ejecuta el análisis del código utilizando Pylint y se devuelve el template \textit{running\_pylint.html}.
		\item \textit{running}: Espera un tiempo determinado y comprueba si la función asíncrona que ejecuta el análisis del código ha finalizado. En caso de que haya finalizado, devuelve el template \textit{repo\_data\_pylint.html}, mientras que si el análisis sigue en ejecución, devuelve otra vez el template \textit{running\_pylint.html}.
		\item \textit{fix\_errors}: Se lanza la función asíncrona que ejecuta la corrección de los errores detectados por Pylint y se devuelve el template \textit{fixing\_errors.html}.
		\item \textit{fixing}: Espera un tiempo determinado y comprueba si la función asíncrona que ejecuta la corrección del código ha finalizado. En caso de que haya finalizado, devuelve el template \textit{repo\_data\_success.html}, mientras que si el análisis sigue en ejecución, devuelve otra vez el template \textit{fixing\_errors.html}.
	\end{itemize}
	\item \textbf{list}: Obtiene la lista de repositorios analizados y devuelve el template \textit{list.html}. 
	\item \textbf{error\_list}: Obtiene el número de errores corregidos y el estado de las Pull-Requests/Merge-Requests realizadas y  devuelve el template \textit{error\_list.html}.
	\item \textbf{guide}: Devuelve el template \textit{guide.html}.
	\item \textbf{contact}: Devuelve el template \textit{contact.html}.
	\item \textbf{es}: Cambia el valor de la variable de sesión correspondiente al idioma para visualizar el sitio en castellano y redirige a la página principal.
	\item \textbf{en}: Cambia el valor de la variable de sesión correspondiente al idioma para visualizar el sitio en inglés y redirige a la página principal.
\end{itemize}
Además, todas las vistas tienen una parte común al recibir un GET: comprueban el estado de las Pull-Requests/Merge-Requests para actualizarlo en la base de datos si éste ha cambiado y también comprueban el valor de la variable de sesión correspondiente al idioma para así devolver las templates en castellano o en inglés según corresponda.

\subsubsection{Templates}
\label{subsubsec:django_templates}
Las plantillas HTML del proyecto se encuentran divididas en los directorios \textit{templates/en} y \textit{templates/es}. Las plantillas de un directorio son prácticamente iguales a las del otro, diferenciándose únicamente en el idioma de los textos.

Las plantillas y sus contenidos son las siguientes:
\begin{itemize}
	\item \textbf{base.html}: Fichero base que extienden el resto de plantillas. Define el banner, el fondo y el menú lateral y su funcionamiento mediante un script.
	\item \textbf{main.html}: Contiene el formulario de introducción de repositorios.
	\item \textbf{error.html}: Muestra el mensaje de error que se le pase como parámetro.
	\item \textbf{error\_repo.html}: Muestra un mensaje de error indicando que el formulario no se ha rellenado con una URL que pertenezca a un repositorio.
	\item \textbf{request\_exists.html}: Informa de que ya existe una Pull-Request/Merge-Request abierta para el repositorio indicado y muestra una tabla con la información de dicho repositorio y la petición realizada.
	\item \textbf{repo\_data.html}: Muestra una tabla con la información del repositorio introducido y un formulario para ejecutar el análisis con Pylint. Dicho formulario es sustituido por una imagen en movimiento al ser pulsado.
	\item \textbf{running\_pylint.html}: Muestra una tabla con la información del repositorio introducido y una imagen y mensaje informando de que se está realizando el análisis. Mediante un script, al terminar la carga realiza una redirección ejecutando un POST al recurso \textit{/repo/id} con un body con el mensaje ``running''.
	\item \textbf{repo\_data\_pylint.html}: Muestra una tabla con la información del repositorio introducido, los errores detectados en el análisis realizado por Pylint y un botón para ejecutar la corrección. Mediante pestañas se puede filtrar para ver todos los errores o sólo los errores corregibles por la aplicación.
	\item \textbf{fixing\_errors.html}: Muestra una tabla con la información del repositorio introducido y una imagen y mensaje informando de que se está realizando la corrección del código. Mediante un script, al terminar la carga realiza una redirección ejecutando un POST al recurso \textit{/repo/id} con un body con el mensaje ``fixing''.
	\item \textbf{repo\_data\_success.html}:  Muestra una tabla con la información del repositorio introducido y añade una nueva fila con el enlace a la Pull-Request/Merge-Request realizada.
	\item \textbf{list.html}: Muestra una tabla con la lista de las Pull-Requests/Merge-Requests realizadas por la aplicación. Mediante pestañas se puede realizar un filtrado según el estado de cada una.
	\item \textbf{error\_list.html}: Hace uso de la librería de JavaScript Chart.js~\ref{sec:chartjs} para representar dos gráficas, una con el recuento de errores y otra con el estado de las Pull-Requests/Merge-Requests realizadas.
	\item \textbf{guide.html}: Contiene un resumen sobre la aplicación, una breve guía de uso definiendo cada una de las páginas y una tabla con los errores detectados por Pylint que son corregibles por la aplicación.
	\item \textbf{contact.html}: Contiene los datos de contacto.
	\item \textbf{theme.css}: Hoja de estilo para personalizar el aspecto de los elementos HTML de la aplicación.
\end{itemize}

\subsection{Errores de Pylint}
\label{subsec:errores}

En el fichero \textit{pylint\_errors.py} se definen qué errores detectados por Pylint van a ser corregidos y cómo va a llevarse a cabo la corrección. 
El listado de errores corregibles por la aplicación se puede visualizar en la tabla~\ref{tabla:errores}.

Pylint indica dónde aparecen los errores mediante el número de línea en el que se encuentran, por lo que para realizar la corrección se ha hecho uso de placeholders que se añaden al código e indican si una determinada línea tiene un error y de qué tipo es.
De esta forma no se cambian las líneas de posición y se evitan posibles modificaciones en las líneas incorrectas.
Una vez terminada la colocación de los placeholders para todo el código, se vuelve a escanear el fichero línea por línea y se aplica la corrección correspondiente para cada placeholder encontrado.
\begin{table}
 \begin{center}
  \begin{tabular}{ | l | c | c |}
    \hline
    \textbf{Error ID} & \textbf{Error Name} & \textbf{Message} \\ \hline
    C0303 & trailing-whitespace & \makecell[l]{Trailing whitespace. Used when there is whitespace\\between the end of a line and the newline.} \\ \hline
    C0304 & missing-final-newline & \makecell[l]{Final newline missing. Used when the last line in\\a file is missing a newline.} \\ \hline
    C0321 & multiple-statements & \makecell[l]{More than one statement on a single line. Used when\\more than on statement are found on the same line.} \\ \hline
    C0326 & bad-whitespace & \makecell[l]{\%s space \%s \%s \%s. Used when a wrong number of spaces\\is used around an operator, bracket or block opener.} \\ \hline
    C0410 & multiple-imports & \makecell[l]{Multiple imports on one line (\%s). Used when import\\statement importing multiple modules is detected.} \\ \hline
    C0411 & wrong-import-order & \makecell[l]{\%s should be placed before \%s. Used when PEP8\\import order is not respected (standard imports first, then\\third-party libraries, then local imports).} \\ \hline
    C0413 & wrong-import-position & \makecell[l]{Import "\%s" should be placed at the top of the\\module. Used when code and imports are mixed.} \\ \hline
    W0404 & reimported & \makecell[l]{Reimport \%r (imported line \%s). Used when a module\\is reimported multiple times.} \\ \hline
    W0611 & unused-import & \makecell[l]{Unused \%s. Used when an imported module or\\variable is not used.} \\ \hline
  \end{tabular}
  \label{tabla:errores}
  \caption{Errores detectados por Pylint corregibles por la aplicación.}
 \end{center}
\end{table}

\subsection{Base de datos}
\label{subsec:diseño_bbdd}

La estructura de la base de datos queda definida en el fichero \textit{models.py} de Django y tiene la forma representada en la figura~\ref{fig:models}.
Está compuesta por las siguientes tablas:
\begin{itemize}
	\item \textbf{Errors}: Contiene la información relativa a todos los errores detectables por Pylint y si son corregibles o no por la aplicación.
	\item \textbf{Repository}: Almacena la información de todos los repositorios que han sido analizados por la aplicación y las Pull-Requests/Merge-Requests que se han llevado a cabo.
	\item \textbf{All\_errors\_repo}: Guarda los errores que se han detectado en cada repositorio.
	\item \textbf{Fixed\_errors\_repo}: Guarda los errores que se han detectado en cada repositorio y además han sido corregidos por la aplicación.
	\item \textbf{All\_errors\_count}:  Almacena el número de veces que se ha detectado cada error.
	\item \textbf{Fixed\_errors\_count}: Almacena el número de veces que se ha corregido cada error.
\end{itemize}

Es una base de datos PostgreSQL provisionada por Heroku y externa a la aplicación Django.

\begin{figure}
  \centering
  \includegraphics[width=16cm, keepaspectratio]{img/models.png}
  \caption{Modelo de datos.}\label{fig:models}
\end{figure}

\subsection{Despliegue}
\label{subsec:diseño_despliegue}

El despliegue de la aplicación se ha configurado para que se lleve a cabo de manera automática mediante el uso de las GitHub Actions y Heroku.

\subsubsection{Github}
\label{subsubsec:despliegue_github}

Cuando se realiza un push y se suben los nuevos commits a GitHub, se ejecutan automáticamente las GitHub Actions definidas en el directorio \textit{/.github/workflows/}.

El fichero \textit{main.yml}, ubicado en dicho directorio, hace uso de la GitHub Action \textit{akhileshns/heroku-deploy@v3.12.12}~\cite{herokudeploy}, logrando así que la aplicación se despliegue automáticamente en Heroku cada vez que se hace push al repositorio que contiene el código.

\subsubsection{Heroku}
\label{subsubsec:despliegue_heroku}
Para llevar a cabo el despliegue de la aplicación en Heroku es necesaria la configuración de dos ficheros, \textit{Procfile} y \textit{requirements.txt}.

\textit{Procfile} especifica los comandos que se van a ejecutar durante el despliegue de la aplicación en Heroku.
Para esta aplicación se especifica que se deben realizar las migraciones del modelo de datos en el momento del lanzamiento, o \textit{release}, por si se hubiese llevado a cabo alguna modificación en \textit{models.py}, y se ejecuta el comando \textit{runserver} como un proceso de tipo web para que sea accesible y pueda recibir peticiones HTTP desde fuera de Heroku.

El fichero \textit{requirements.txt} hace que Heroku identifique automáticamente la aplicación como una aplicación desarrollada en Python y en su interior se definen las dependencias, incluyendo la versión, que deben ser instaladas antes del arranque de la aplicación en Heroku.
Para esta aplicación \textit{requirements.txt} contiene paquetes Python como \textit{Django}, \textit{Pylint}, o \textit{requests}, entre otros.

Además, para que Django funcione correctamente al desplegarse en Heroku, hay que realizar cambios dentro del código del proyecto.
El fichero \textit{settings.py} se modifica para que Django utilice la base de datos PostgreSQL proporcionada por Heroku y se modifica el fichero \textit{views.py} para que haga uso de las variables de configuración de Heroku, que contendrán datos como los token de GitHub y Gitlab.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% EXPERIMENTOS Y VALIDACIÓN %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\chapter{Experimentos y validación}
\label{chap:experimentos}

\section{Tests unitarios}
\label{sec:tests_unitarios}

Para comenzar las pruebas del correcto funcionamiento de la aplicación se ha hecho uso de la herramienta de tests unitarios incluida en Django.
Dichos tests unitarios se encuentran en el fichero \textit{/analyzerapp/tests.py} y están diseñados para comprobar que las funciones correspondientes a cada error son capaces de situar correctamente el placeholder indicado en las líneas afectadas, y que las funciones que corrigen los errores al encontrar un placeholder son capaces de hacerlo correctamente.
\begin{figure}[h]
  \centering
  \includegraphics[width=10cm, keepaspectratio]{img/tests.png}
  \caption{Salida de la ejecución de los tests unitarios en Django.}\label{fig:tests}
\end{figure}

La salida de la ejecución de los tests unitarios desde el propio Django puede ser observada en la figura~\ref{fig:tests}. En ella se refleja que la ejecución de los tests unitarios es exitosa tanto para los nueve tests correspondientes a las funciones que añaden los placeholders, como para los cuatro tests correspondientes a la corrección de los errores y borrado de los placeholders.

\section{Análisis y corrección de proyectos en local}
\label{sec:tests_local}

Tras comprobar el correcto funcionamiento de las funciones de corrección de errores mediante los tests unitarios, el siguiente paso ha sido realizar pruebas con proyectos en local para comprobar que se realiza correctamente tanto el análisis con Pylint como la corrección de los errores detectados.
En estas primeras pruebas no se ha ejecutado la aplicación utilizando Django, se ha creado un script con el contenido de las funciones del fichero \textit{views.py} y se ha ejecutado el análisis y la corrección ejecutando dicho script.

El primer paso ha sido realizar las pruebas con un único fichero, para ello se ha creado dos ficheros con las mismas sentencias de Python.
El primero de ellos contiene errores corregibles por la aplicación, mientras que el segundo de ellos cumple con todas las normas de estilo que indican los errores que la aplicación es capaz de corregir.

Es durante esta prueba cuando se observa que, al realizar las correcciones del código al mismo tiempo que se recorre el fichero con la salida de Pylint, algunas sentencias pueden sufrir cambios en su número de línea, lo que puede provocar que se realicen modificaciones en las líneas equivocadas y el fichero no pueda ejecutarse por errores de sintaxis.
Para solucionar este problema se toma la decisión de no realizar acciones que puedan cambiar los números de línea de ninguna sentencia mientras se lee la salida de Pylint y, para ello, únicamente se llevará a cabo la colocación de placeholders durante esta lectura.
Estos placeholders indican qué acción hay que realizar sobre la línea en la que se encuentran y, si fuese necesario, un número indicando en qué posición de la línea se encuentra el problema.
Al terminar de situar los placeholders en el fichero se vuelve a recorrer el mismo buscando dichos placeholders y realizando la acción correspondiente para corregir el error.

Tras solventar dicho problema, se procede a ejecutar la aplicación sobre el fichero que contiene los errores y se observa que ambos fichero son totalmente idénticos, por lo que se confirma que la aplicación ha funcionado correctamente al ser ejecutada sobre un único fichero con errores.

Después de comprobar que el análisis y la corrección sobre un único fichero ha tenido éxito, el siguiente paso es realizarlo sobre un proyecto que contenga distintos directorios y ficheros, incluyendo tanto ficheros con extensión \textit{.py} como ficheros con otras extensiones o sin extensión.
Para ello se han creado copias del fichero inicial que contenía los errores y se han distribuido en diferentes directorios dentro de un mismo proyecto realizando cambios en el nombre para poder tener varios en el mismo directorio y eliminando la extensión para comprobar que no se ven afectados por el análisis.
Tras ejecutar la aplicación sobre el directorio raíz del proyecto se comprueba que ésta funciona correctamente, ya que todos los ficheros con extensión \textit{.py} contenidos en los diferentes directorios y subdirectorios han sido corregidos y son idénticos al fichero inicial sin errores corregibles, mientras que los ficheros sin extensión \textit{.py} no se han visto modificados por la aplicación.

\section{Análisis y corrección de repositorios en GitHub y GitLab}
\label{sec:tests_repositorios}

Para poder comprobar que la aplicación al completo funciona correctamente se ha dejado de usar el script indicado en la sección~\ref{sec:tests_local} y se ha levantado la aplicación Django en local.
Tras tener la aplicación Django funcionando correctamente, se ha creado un repositorio en GitHub que contiene un único fichero como el indicado en la primera prueba exitosa de la sección~\ref{sec:tests_local} y se ha introducido la URL de dicho repositorio en el formulario de la página principal de la aplicación.
Una vez terminado el proceso, se comprueba que se ha realizado la Pull-Request y que ésta contiene un commit modificando el único fichero del repositorio que, en caso de realizarse el \textit{merge} de la Pull-Request con el repositorio, pasa a ser idéntico al fichero inicial sin los errores corregibles por la aplicación. También se comprueba que la Pull-Request realizada contiene en su descripción un breve mensaje con un enlace a la aplicación y a la documentación de la guía de estilo PEP8 y después el listado con los errores que han sido corregidos por la aplicación tal y como los muestra Pylint en su salida.

En este proceso se recibe un mensaje de GitHub notificando que la autenticación mediante usuario y contraseña al usar la API va a ser deshabilitada próximamente, por lo que se modifica el método de autenticación para usar un token de acceso y se comprueba que el proceso de creación de la Pull-Request sigue funcionando correctamente.

Tras esta corrección y la creación de la Pull-Request de manera exitosa, se realiza el mismo proceso utilizando el proyecto con múltiples directorios y ficheros que se ha usado en la segunda parte de la sección~\ref{sec:tests_local}.
Al finalizar el proceso se observa que se ha realizado la creación de la Pull-Request de manera adecuada, modificando correctamente todos los ficheros con extensión \textit{.py} y dejando intactos los que no tienen ninguna extensión.
Por último, se prueba a aceptar una de las Pull-Requests y a cancelar la otra y se comprueba que la aplicación realiza la consulta a la API de GitHub para obtener el estado de las Pull-Requests y lo actualiza correctamente en la base de datos.

Estos dos mismos experimentos se repiten utilizando un repositorio alojado en el GitLab de la ETSIT de la URJC en lugar de GitHub y, como en el caso anterior, ambas pruebas concluyen de manera satisfactoria.

\section{Aplicación desplegada en Heroku}
\label{sec:tests_heroku}

Como última prueba, se realiza el despliegue de la aplicación en Heroku y se repiten las pruebas utilizando repositorios con subdirectorios y múltiples ficheros alojados en GitHub y en el GitLab de la ETSIT de la URJC.
Estas pruebas tienen el mismo resultado que al haber desplegado la aplicación Django en local, por lo que se puede validar el funcionamiento correcto de la aplicación completa ya desplegada en Heroku y siendo accesible desde Internet, finalizando así las pruebas y tests ejecutados sobre la aplicación.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% RESULTADOS %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\chapter{Resultados}
\label{chap:resultados}

Una vez terminada la fase de pruebas, se borra el contenido de la base de datos para no mezclar los datos de las pruebas con los datos reales y se procede a utilizar la aplicación con repositorios reales alojados en GitHub.
Para ello se escogen algunos proyectos correspondientes a la práctica final de la asignatura Servicios y Aplicaciones Telemáticas realizadas por compañeros de la carrera y se buscan proyectos Python en GitHub que tengan actividad reciente.

Al introducir el primero de estos proyectos, debido a su tamaño, el tiempo de análisis con Pylint es superior al de las pruebas realizadas previamente y se produce un \emph{timeout} ya que el servidor tarda más de treinta segundos en devolver una respuesta HTTP al cliente.

Para solucionarlo se intenta cambiar el valor de dicho \emph{timeout}, pero tras revisar la documentación de Heroku se observa que no es posible modificarlo.
Por lo tanto, se procede a programar el análisis con Pylint como una tarea asíncrona con el servidor comprobando periódicamente si dicha tarea ha finalizado o no.
Dicha solución se aplica también para la tarea de corrección de los errores detectados, ya que puede provocar el mismo fallo.

Tras realizar estos cambios se vuelve a introducir el repositorio que ha provocado el fallo y se comprueba que el análisis y la corrección se llevan a cabo de manera satisfactoria y que se permite que el tiempo de los mismos sea superior a treinta segundos sin provocar un \emph{timeout}.
También se comprueba que la Pull-Request se ha generado correctamente y ha quedado abierta a la espera de que el propietario del repositorio la acepte o la cancele.

Una vez realizados diez Pull-Requests sobre repositorios de proyectos reales, se procede a analizar cuáles son los errores más corregidos y más detectados por la aplicación.

En la figura~\ref{fig:errores_detectados} se puede observar una gráfica en la que se representa el número de errores detectados por la aplicación para los diez más frecuentes en los repositorios analizados.
Entre estos diez errores más frecuentes se encuentran dos de los que son corregibles por la aplicación: \textit{C0326: bad-whitespace} y \textit{C0303: trailing-whitespace}.
El resto de errores se encuentran junto a su ID y su mensaje de error en la tabla~\ref{tabla:errores_detectados}.

Entre los errores detectados por la aplicación, el más repetido es \textit{C0326: bad-whitespace}, que además es corregible, habiendo sido detectado un total de 2541 veces.
Los dos siguientes errores también superan las mil repeticiones totales para los diez análisis realizados. Estos errores son \textit{C0103: invalid-name}, repetido 1465 veces y \textit{C0116: missing-function-docstring}, con 1146 detecciones.
El resto de errores detectados se encuentran por debajo de las 600 repeticiones.
Para los diez análisis realizados, se han detectado 108 errores distintos, de los 349 posibles, con un recuento total de 9566 detecciones.
\newline
\begin{figure}[h]
  \centering
    \begin{tikzpicture}
      \begin{axis}[
        symbolic y coords={
        	redefined-outer-name,
        	missing-module-docstring,
        	bad-continuation,
        	trailing-whitespace,
        	no-member,
        	mixed-indentation,
        	bad-indentation,
        	missing-function-docstring,
        	invalid-name,
        	bad-whitespace
        	},
        xmin = 0,
        xmax = 3000,
        xlabel={Número de detecciones},
        width=12cm,height=8cm,
        ytick=data
        ]
        \addplot[xbar,fill=blue] coordinates {
          (2541,bad-whitespace)
          (1465,invalid-name)
          (1146,missing-function-docstring)
          (535,bad-indentation)
          (450,mixed-indentation)
          (345,no-member)
          (280,trailing-whitespace)
          (278,bad-continuation)
          (248,missing-module-docstring)
          (199,redefined-outer-name)
        };
      \end{axis}
    \end{tikzpicture}
  \caption{Cantidad de detecciones por error.}\label{fig:errores_detectados}
\end{figure}
\newpage
\begin{table}[h]
 \begin{center}
  \begin{tabular}{ | l | c | c |}
    \hline
    \textbf{Error ID} & \textbf{Error Name} & \textbf{Message} \\ \hline
    C0103 & invalid-name & \makecell[l]{\%s name "\%s" doesn't conform to \%s. Used when the\\name doesn't conform to naming rules associated\\to its type (constant, variable, class...).} \\ \hline
    C0116 & missing-function-docstring & \makecell[l]{Missing function or method docstring. Used when a\\function or method has no docstring.Some special\\methods like \_\_init\_\_ do not require a docstring.} \\ \hline
    W0311 & bad-indentation & \makecell[l]{Bad indentation. Found \%s \%s, expected \%s. Used\\when an unexpected number of indentation's\\tabulations or spaces has been found.} \\ \hline
    W0312 & mixed-indentation & \makecell[l]{Found indentation with \%ss instead of \%ss. Used\\when there are some mixed tabs and spaces in a module.} \\ \hline
    E1101 & no-member & \makecell[l]{\%s \%r has no \%r member\%s. Used when a variable\\is accessed for an unexistent member.} \\ \hline
    C0330 & bad-continuation & \makecell[l]{Wrong \%s indentation\%s\%s.} \\ \hline
    C0114 & missing-module-docstring & \makecell[l]{Missing module docstring. Used when a module\\has no docstring.Empty modules do not require a\\docstring.} \\ \hline
    W0621 & redefined-outer-name & \makecell[l]{Redefining name \%r from outer scope (line \%s).\\Used when a variable's name hides a name defined\\in the outer scope.} \\ \hline
  \end{tabular}
  \label{tabla:errores_detectados}
  \caption{Errores detectados por Pylint corregibles por la aplicación.}
 \end{center}
\end{table}

En la figura~\ref{fig:errores_corregidos} se puede observar una gráfica en la que se representa el número correcciones que se han llevado a cabo para cada uno de los errores que son corregibles por la aplicación.

Los 9 errores corregibles por la aplicación han sido detectados y solucionados al menos una vez durante los 10 análisis realizados.
Los dos errores más corregidos son los que ya aparecían en la lista de errores más detectados, con 2541 repeticiones para \textit{C0326: bad-whitespace} y 280 para \textit{C0303: trailing-whitespace}.
Para los siguientes errores corregidos, \textit{C0321: multiple-statements} se ha repetido 190 veces, \textit{C0304: missing-final-newline} ha tenido 113 apariciones y \textit{W0611: unused-import} ha sido corregido 108 veces.
Con menos de 100 correcciones se encuentran \textit{C0411: wrong-import-order}, con 84, y \textit{C0413: wrong-import-position}, que ha sido corregido 64 veces.
Mientras que los dos errores con menos correcciones son \textit{W0404: reimported} y \textit{C0410: multiple-imports} con 9 y 7 correcciones cada uno respectivamente
Estos 9 errores suman un total de 3396 correcciones para los 10 análisis que se han llevado a cabo.
\newline
\begin{figure}[h]
  \centering
    \begin{tikzpicture}
      \begin{axis}[
        symbolic y coords={
        	multiple-imports,
        	reimported,
        	wrong-import-position,
        	wrong-import-order,
        	unused-import,
        	missing-final-newline,
        	multiple-statements,
        	trailing-whitespace,
        	bad-whitespace
        	},
        xmin = 0,
        xmax = 3000,
        xlabel={Número de correcciones},
        width=12cm,height=7cm,
        ytick=data
        ]
        \addplot[xbar,fill=blue] coordinates {
          (2541,bad-whitespace)
          (280,trailing-whitespace)
          (190,multiple-statements)
          (113,missing-final-newline)
          (108,unused-import)
          (84,wrong-import-order)
          (64,wrong-import-position)
          (9,reimported)
          (7,multiple-imports)
        };
      \end{axis}
    \end{tikzpicture}
  \caption{Cantidad de correcciones por error.}\label{fig:errores_corregidos}
\end{figure}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% CONCLUSIONES %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\chapter{Conclusiones}
\label{chap:conclusiones}

\section{Consecución de objetivos}
\label{sec:consecucion-objetivos}

Como se ha indicado en la sección~\ref{sec:objetivo-general}, el objetivo principal del proyecto era desarrollar una aplicación que analizase mediante Pylint repositorios de GitHub con código Python y corrigiera algunos de los errores encontrados en dicho código para cumplir con la guía de estilo PEP8 realizando finalmente Pull-Requests para sugerir al propietario del repositorio las modificaciones que se han llevado a cabo.
Este objetivo principal se ha cumplido en su totalidad, la aplicación es capaz de analizar código Python almacenado en GitHub y corrige los 9 errores indicados en la tabla~\ref{tabla:errores} para, finalmente, subir estas modificaciones a GitHub mediante el uso de Pull-Requests.

Respecto a los objetivos específicos, el resultado para cada uno de ellos ha sido el siguiente:
\begin{itemize}
	\item \textbf{Trabajar con proyectos reales}: Una vez finalizado el desarrollo de la aplicación, se ha podido probar su funcionamiento con proyectos reales.
	\item \textbf{Aplicación web}: La aplicación ha sido desarrollada como una aplicación web mediante el uso de Django.
	\item \textbf{Accesibilidad desde Internet}: Se ha logrado la accesibilidad desde Internet mediante el despliegue de la aplicación en Heroku.
	Este despliegue tiene algunas limitaciones causadas por el uso de la versión gratuita de Heroku.
	La principal limitación se encuentra en la base de datos que proporciona la plataforma, ya que no se permite que ésta contenga más de diez mil filas.
	Otra limitación provocada por la versión gratuita de Heroku es la entrada en reposo de la aplicación pasado un determinado tiempo de inactividad.
	Esto causa que si un usuario accede a la aplicación cuando se encuentra en reposo, deberá esperar unos segundos mientras la aplicación arranca para poder hacer uso de la misma.
	\item \textbf{Compatibilidad con el servidor GitLab de la ETSIT}: La aplicación es totalmente compatible con el servidor GitLab de la ETSIT y permite realizar sobre sus repositorios las mismas acciones que sobre los repositorios de GitHub.
	\item \textbf{Análisis de aceptación de las Pull-Requests}: La aplicación comprueba el estado de las Pull-Requests que se han realizado y lo actualiza en la base de datos para mostrarlo correctamente en las gráficas.
\end{itemize}

\section{Aplicación de lo aprendido}
\label{sec:aplicacion}

En el desarrollo de este proyecto se han aplicado conocimientos adquiridos en las siguientes asignaturas:

\begin{itemize}
  \item \textbf{Fundamentos de la Programación}: Introducción a la programación, necesaria para poder entender las asignaturas de programación que se estudian más adelante.
  \item \textbf{Arquitectura de Redes de Ordenadores}: Esta asignatura introduce por primera vez los protocolos usados en las redes, como el protocolo HTTP, necesario para el funcionamiento de las aplicaciones web como la desarrollada en este proyecto.
  \item \textbf{Programación de Sistemas de Telecomunicación}: Se profundiza en el uso de protocolos, la programación de tareas asíncronas y se presenta la arquitectura cliente-servidor en la que se basa la aplicación.
  \item \textbf{Sistemas Operativos}: Asignatura que, entre otras cosas, explica el uso básico de Linux, necesario para el tratamiento de ficheros y ejecución de comandos del sistema operativo que realiza la aplicación.
  \item \textbf{Servicios y Aplicaciones Telemáticas}: Asignatura base para el desarrollo de este proyecto. En ella se tiene el primer contacto con git, Python, HTML, CSS y Django, tecnologías en las que se basa la aplicación desarrollada. También se presenta la guía de estilo PEP8.
  \item \textbf{Ingeniería de Sistemas de Información}: Presenta el uso de las bases de datos, el lenguaje SQL, los tests unitarios y el despliegue de aplicaciones en Heroku. También profundiza en el uso de git.
  \item \textbf{Desarrollo de Aplicaciones Telemáticas}: Se introduce JavaScript y jQuery y se muestra qué es una API y cómo comunicarse con ella.
\end{itemize}

\section{Lecciones aprendidas}
\label{sec:lecciones_aprendidas}

De lo aprendido durante la elaboración del Trabajo de Fin de Grado se podría destacar lo siguiente:

\begin{itemize}
  \item La profundización en Python y Django, que ha permitido añadir conocimientos a lo aprendido previamente durante las asignaturas de la carrera.
  \item La posibilidad de realizar Pull-Requests en GitHub y así poder sugerir modificaciones y colaborar en proyectos de otros usuarios.
  \item GitLab. Desconocía la existencia de plataformas de almacenamiento de repositorios además de GitHub y que además permitía la creación de servidores privados en los que alojar los proyectos.
  \item Cómo funcionan las APIs de GitHub y GitLab y su sistema de autenticación mediante token.
\end{itemize}

\section{Trabajos futuros}
\label{sec:trabajos_futuros}

Aunque cumpla los objetivos propuestos, este proyecto tiene la posibilidad de ser mejorado y ampliado en el futuro, algunas de estas posibles mejoras son las siguientes:

\begin{itemize}
  \item Añadir más errores corregibles por la aplicación. 
  \item Mejorar la velocidad de corrección mediante la posibilidad de corregir los ficheros en paralelo en lugar de secuencialmente como se realiza ahora.
  \item Añadir compatibilidad con el servidor público y global de Gitlab además de con otras plataformas de almacenamiento de repositorios como Bitbucket.
  \item Despliegue en una plataforma sin las limitaciones producidas por Heroku actualmente.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% APÉNDICE(S) %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\appendix
\chapter{Manual de usuario}
\label{app:manual}
%TODO
Esto es un apéndice.
Si has creado una aplicación, siempre viene bien tener un manual de usuario.
Pues ponlo aquí.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% BIBLIOGRAFIA %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage

% Las siguientes dos instrucciones es todo lo que necesitas
% para incluir las citas en la memoria
\bibliographystyle{abbrv}
\bibliography{memoria}  % memoria.bib es el nombre del fichero que contiene
% las referencias bibliográficas. Abre ese fichero y mira el formato que tiene,
% que se conoce como BibTeX. Hay muchos sitios que exportan referencias en
% formato BibTeX. Prueba a buscar en http://scholar.google.com por referencias
% y verás que lo puedes hacer de manera sencilla.
% Más información: 
% http://texblog.org/2014/04/22/using-google-scholar-to-download-bibtex-citations/

\end{document}
